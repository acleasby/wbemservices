/*
 *EXHIBIT A - Sun Industry Standards Source License
 *
 *"The contents of this file are subject to the Sun Industry
 *Standards Source License Version 1.2 (the "License");
 *You may not use this file except in compliance with the
 *License. You may obtain a copy of the 
 *License at http://wbemservices.sourceforge.net/license.html
 *
 *Software distributed under the License is distributed on
 *an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, either
 *express or implied. See the License for the specific
 *language governing rights and limitations under the License.
 *
 *The Original Code is WBEM Services.
 *
 *The Initial Developer of the Original Code is:
 *Sun Microsystems, Inc.
 *
 *Portions created by: Sun Microsystems, Inc.
 *are Copyright Â© 2002 Sun Microsystems, Inc.
 *
 *All Rights Reserved.
 *
 *Contributor(s): _______________________________________
*/

package org.wbemservices.wbem.compiler.mofc;

import java.util.Enumeration;
import java.util.Vector;

import javax.wbem.cim.CIMClass;
import javax.wbem.cim.CIMDataType;
import javax.wbem.cim.CIMMethod;
import javax.wbem.cim.CIMParameter;
import javax.wbem.cim.CIMProperty;

/**
 * This class generates the Java Bean source that represents
 * the specified CIMClass. The Java Beans generated by this
 * class implement the corresponding Java Interfaces generated
 * by BeanInterfaceWriter.
 *
 * NOTE: Existing <CIM class>BeanImpl.java files in the output
 * directory will be overwritten.
 */
class BeanClassWriter implements BeanGeneratorConstants {

    // relevant data needed to generate src
    //
    private CIMClass		cimClass = null;
    private String		versionStr = null;
    private boolean		isAbstractClass = false;
    private Vector		vProperties = null;
    private Vector		vKeys = null;
    private Vector		vMethods = null;
    private String		superClass = null;
    private String		className = null;

    private final static String	invalidChars = 
	"!@#$%^&*(-){[}}+=?/\"'<,>.:;\\| 	";

    /**
     * Constructs a BeanClassWriter to generate Bean Intefaces from MOFs.
     * 
     * @param cimClass the CIMClass for the MOF being compiled
     */
    public BeanClassWriter(CIMClass cimClass) {

	super();
	this.cimClass = cimClass;
	this.vProperties = cimClass.getProperties();
	this.isAbstractClass = BeanGenerator.hasQualifier(cimClass, ABSTRACT);

	// set I18N Bundle
	I18N.setResourceName("org.wbemservices.wbem.compiler.mofc.Compiler");

	populateClassData();
	generateClass();

    } // constructor

    /**
     * This method gets the information from the CIMClass needed to
     * generate the Class source code.
     */
    private void populateClassData() {

	this.superClass = BeanGenerator.getSuperClass(cimClass);
	this.className = BeanGenerator.getClassName(cimClass.getName());
	this.vKeys = cimClass.getKeys();
	this.vMethods = cimClass.getMethods();

    } // populateClassData

    /**
     * This method directs the generation of the Class source code.
     */
    private void generateClass() {

	StringBuffer nameBuffer = new StringBuffer(className);
	nameBuffer.append(BEANIMPL);
	StringBuffer sb = new StringBuffer();

	sb.append(BeanGenerator.getFileHeader());
	sb.append(BeanGenerator.getPackageStatement());
	sb.append(BeanGenerator.getImportStatements());
	sb.append(getClassOpen());
	sb.append(getClassVariables());
	sb.append(getConstructor());
	// only override CIMBeanImpl.getVersion()'s base implementation
	// if there's a Version qualifier for the CIM class.
	//
	if (BeanGenerator.hasQualifier(cimClass, VERSION)) {

	    sb.append(getVersionMethod());

	}

	// CIM classes without key qualified properties don't need the
	// following code
	//
	if (BeanGenerator.hasContents(vKeys)) {

	    sb.append(getBeanKeysMethod());

	}
	sb.append(getPropertyMethods());
	sb.append(getInvokeMethods());
	sb.append(getClassClose());
	BeanGenerator.writeToFile(nameBuffer, sb);

    } // generateClass

    /**
     * This method returns the JavaDoc for the Class and the line of 
     * code defining the Class.
     *
     * @return	StringBuffer	Class JavaDoc and class definition statement
     */
    private StringBuffer getClassOpen() {

	StringBuffer sb = new StringBuffer();
	String beanDesc = I18N.loadStringFormat("BEAN_CLASS_JAVADOC",
	    className);
	StringBuffer mofDesc = BeanGenerator.getClassDescription(cimClass);
	sb.append(BeanGenerator.getJavaDoc(beanDesc, mofDesc, (Vector)null, 0));

	String formatStr = BeanGenerator.hasQualifier(cimClass, TERMINAL) ?
	    CLASS_FINAL_OPEN : CLASS_OPEN;
	sb.append(BeanGenerator.getSourceLine(BeanGenerator.format(
	    formatStr, className, superClass) + OPEN_BRACE + RETURN, 0));
	return (sb);

    } // getClassOpen

    /**
     * This method returns the code defining the class variables.
     *
     * @return	StringBuffer	code for the Class variable declarations
     */
    private StringBuffer getClassVariables() {

	StringBuffer sb = BeanGenerator.getSourceLine(CIMOMHANDLE_VARIABLE, 1);
	sb.append(BeanGenerator.getSourceLine(CIMINSTANCE_VARIABLE, 1));
	String keysStr = "null";
	if (BeanGenerator.hasContents(vKeys)) {

	    Enumeration eKeys = vKeys.elements();
	    CIMProperty cimProp;
	    keysStr = "{";
	    while (eKeys.hasMoreElements()) {

		cimProp = (CIMProperty)eKeys.nextElement();
		keysStr += "\"" + cimProp.getName() + "\", ";

	    }
	    keysStr = keysStr.substring(0, keysStr.lastIndexOf(",")) + 
		CLOSE_BRACE;

	}
	sb.append(BeanGenerator.getSourceLine(BeanGenerator.format(
	    KEY_ARRAY_VARIABLE, keysStr), 1));
	if (BeanGenerator.hasQualifier(cimClass, VERSION)) {

	    versionStr = BeanGenerator.getQualifier(cimClass, VERSION);
	    sb.append(BeanGenerator.getSourceLine(BeanGenerator.format(
		VERSION_VARIABLE, versionStr), 1));

	}
	return (sb.append(RETURN));

    } // getClassVariables

    /**
     * This method returns the JavaDoc and constructor for the Class.
     *
     * @return	StringBuffer	JavaDoc and class constructor
     */
    private StringBuffer getConstructor() {

	String constructorDesc = I18N.loadStringFormat(
	    "BEAN_CONSTRUCTOR_JAVADOC", className);
	StringBuffer mofDesc = BeanGenerator.getClassDescription(cimClass);

	// create the JavaDocElements for the constructor parameters
	//
	Vector vJavaDocElements = new Vector(2);
	JavaDocElement javaDocElement = new JavaDocElement(JAVADOC_PARAM_TAG, 
	    new StringBuffer(CIMOMHANDLE), 
	    I18N.loadString("CIMOM_PARAM_DESCRIPTION"));
	vJavaDocElements.addElement(javaDocElement);

	javaDocElement = new JavaDocElement(JAVADOC_PARAM_TAG, 
	    new StringBuffer(CIMINSTANCE), 
	    I18N.loadString("INSTANCE_PARAM_DESCRIPTION"));
	vJavaDocElements.addElement(javaDocElement);

	// generate the constructor JavaDoc
	//
	StringBuffer sb = BeanGenerator.getJavaDoc(constructorDesc, mofDesc, 
	    vJavaDocElements, 1);

	// generate the constructor
	//
	String constructorStr = CLASS_CONSTRUCTOR;
	if (isAbstractClass) {

	    constructorStr = ABSTRACT_CONSTRUCTOR;

	}
	sb.append(BeanGenerator.getSourceLine(BeanGenerator.format(
	    constructorStr, className) + OPEN_BRACE + RETURN, 1));
	sb.append(BeanGenerator.getSourceLine(BEAN_SUPERCLASS, 2)).append(
	    RETURN);
	sb.append(BeanGenerator.getSourceLine(CIMOM_HANDLE, 2));
	sb.append(BeanGenerator.getSourceLine(CIMINSTANCE_HANDLE, 2)).append(
	    RETURN);
	sb.append(BeanGenerator.getSourceLine(CONSTRUCTOR_CLOSE, 1));
	return (sb.append(RETURN));

    } // getConstructor

    /**
     * This method returns the method which returns the array of strings 
     * containing the names of the key qualified properties in the CIM 
     * class. The getBeanKeys() method is defined as abstract in CIMBean and 
     * is required in each generated Bean in the case that its CIMInstance 
     * does not include qualifier information. Without this ability, the Bean 
     * cannot generate the CIMInstance's CIMObjectPath.
     *
     * @return	StringBuffer	getBeanKeys() abstract method defined in CIMBean
     */
    private StringBuffer getBeanKeysMethod() {

	String keysMethodDesc = I18N.loadString("BEAN_GETKEYS_JAVADOC");
	Vector vJavaDocElements = new Vector(1);
	JavaDocElement javaDocElement = new JavaDocElement(JAVADOC_RETURN_TAG,
	    new StringBuffer(STRING_ARRAY), 
	    I18N.loadString("KEYS_RETURN_DESCRIPTION"));
	vJavaDocElements.addElement(javaDocElement);
	StringBuffer sb = BeanGenerator.getJavaDoc(keysMethodDesc, 
	    new StringBuffer(), vJavaDocElements, 1);
	return (sb.append(GETKEYS_METHOD).append(RETURN));

    } // getBeanKeysMethod

    /**
     * This method returns the method which returns the CIM class Version
     * qualifier value or "-1" if it doesn't have one. The getVersion() 
     * method is defined as abstract in CIMBean and is required in each 
     * generated Bean in order to implement the CIMBean Interface.
     *
     * @return	StringBuffer	getVersion() abstract method defined in CIMBean
     */
    private StringBuffer getVersionMethod() {

	String versionMethodDesc = I18N.loadStringFormat(
	    "BEAN_GETVERSION_JAVADOC", className);
	Vector vJavaDocElements = new Vector(1);
	JavaDocElement javaDocElement = new JavaDocElement(JAVADOC_RETURN_TAG,
	    new StringBuffer(STRING), 
	    I18N.loadString("VERSION_RETURN_DESCRIPTION"));
	vJavaDocElements.addElement(javaDocElement);
	StringBuffer sb = BeanGenerator.getJavaDoc(versionMethodDesc, 
	    new StringBuffer(), vJavaDocElements, 1);
	return (sb.append(GETVERSION_METHOD).append(RETURN));

    } // getVersionMethod

    /**
     * This method returns a properly formatted string containing the 
     * <ClassName>BeanKeys class. This class implements the CIMBeanKeys 
     * Interface to provide a mechanism to convert the key values specified
     * at construction time into a CIMObjectPath.
     * NOTE: This method should only be called if there is a key qualified 
     * properties defined for the CIM class.
     *
     * @return	StringBuffer	the <ClassName>BeanKeys class
     */
    private StringBuffer getBeanKeysClass() {

	StringBuffer sb = new StringBuffer();

	// generated file header, package, and import statements
	//
	sb.append(BeanGenerator.getFileHeader());
	sb.append(BeanGenerator.getPackageStatement());
	sb.append(BeanGenerator.getImportStatements());

	// BeanKeys class JavaDoc
	//
	String beanKeysClassDesc = I18N.loadStringFormat("BEANKEYS_JAVADOC",
	    className);
	sb.append(BeanGenerator.getJavaDoc(beanKeysClassDesc, 
	    new StringBuffer(), (Vector)null, 0));

	// class definition
	//
	sb.append(BeanGenerator.getSourceLine(BeanGenerator.format(
	    BEANKEYS_CLASS_OPEN, className) + OPEN_BRACE + RETURN, 0));

	// class variables for key property values
	//
	Enumeration eKeys = vKeys.elements();
	CIMProperty cimProp;
	while (eKeys.hasMoreElements()) {

	    cimProp = (CIMProperty)eKeys.nextElement();
	    sb.append(BeanGenerator.getSourceLine(BeanGenerator.format(
		CLASS_VARIABLE, BeanGenerator.getDataType(
		cimProp.getType()).toString(), BeanGenerator.getParameterName(
		cimProp.getName())), 1));

	}
	sb.append(RETURN);

	// constructor JavaDoc
	//
	Vector vJavaDocElements = new Vector(vKeys.size());
	addPropsToVector(vJavaDocElements, vKeys);
	sb.append(BeanGenerator.getJavaDoc(I18N.loadStringFormat(
	    "BEANKEYS_CONSTRUCTOR_JAVADOC", className), new StringBuffer(), 
	    vJavaDocElements, 1));

	// constructor open
	//
	sb.append(BeanGenerator.getSourceLine(BeanGenerator.format(
	    BEANKEYS_CONSTRUCTOR_OPEN, className, getBeanKeysParameters()) + 
	    OPEN_BRACE + RETURN, 1));

	// constructor body
	//
	sb.append(BeanGenerator.getSourceLine(SUPERCLASS, 2));
	eKeys = vKeys.elements();
	while (eKeys.hasMoreElements()) {

	    cimProp = (CIMProperty)eKeys.nextElement();
	    sb.append(BeanGenerator.getSourceLine(BeanGenerator.format(
		VARIABLE_HANDLE, BeanGenerator.getParameterName(
		cimProp.getName())), 2));

	}
	sb.append(RETURN);

	// constructor close
	//
	sb.append(BeanGenerator.getSourceLine(CONSTRUCTOR_CLOSE + RETURN, 1));

	// accessor methods for the key properties
	//
	eKeys = vKeys.elements();
	JavaDocElement javaDocElement;
	while (eKeys.hasMoreElements()) {

	    cimProp = (CIMProperty)eKeys.nextElement();

	    // accessor JavaDoc
	    //
	    vJavaDocElements.removeAllElements();
	    javaDocElement = new JavaDocElement(JAVADOC_RETURN_TAG,
		BeanGenerator.getDataType(cimProp.getType()), 
		I18N.loadString("ACCESSOR_RETURN_DESCRIPTION"));
	    vJavaDocElements.addElement(javaDocElement);
	    sb.append(BeanGenerator.getJavaDoc(I18N.loadStringFormat(
		"BEANKEYS_ACCESSOR_JAVADOC", cimProp.getName()), 
		new StringBuffer(), vJavaDocElements, 1));

	    // accessor method
	    //
	    sb.append(getBeanKeysAccessor(cimProp));

	}

	// getCIMObjectPath() JavaDoc
	//
	vJavaDocElements.removeAllElements();
	javaDocElement = new JavaDocElement(JAVADOC_RETURN_TAG, 
	    new StringBuffer(CIMOBJECTPATH), 
	    I18N.loadString("CIMOBJPATH_RETURN_DESCRIPTION"));
	vJavaDocElements.addElement(javaDocElement);
	sb.append(BeanGenerator.getJavaDoc(I18N.loadString(
	    "BEANKEYS_CIMOBJPATH_JAVADOC"), new StringBuffer(), 
	    vJavaDocElements, 1));

	// getCIMObjectPath() open
	//
	sb.append(BeanGenerator.getSourceLine(BEANKEYS_CIMOBJPATH_OPEN + 
	    OPEN_BRACE + RETURN, 1));

	// getCIMObjectPath() body
	//
	sb.append(BeanGenerator.getSourceLine(BEANKEYS_VECTOR_DECL, 2));
	eKeys = vKeys.elements();
	while (eKeys.hasMoreElements()) {

	    cimProp = (CIMProperty)eKeys.nextElement();
	    sb.append(BeanGenerator.getSourceLine(BeanGenerator.format(
		BEANKEYS_VECTOR_ADD, cimProp.getName(), 
		BeanGenerator.getParameterName(cimProp.getName())), 2));

	}
	sb.append(RETURN);
	sb.append(BeanGenerator.getSourceLine(BeanGenerator.format(
	    BEANKEYS_RETURN_DECL, className), 2));

	// getCIMObjectPath() close
	//
	sb.append(BeanGenerator.getSourceLine(CLOSE_BRACE + 
	    BeanGenerator.format(ACCESSOR_CLOSE, CIMOBJECTPATH) + RETURN, 1));

	// close the class
	//
	sb.append(BeanGenerator.getSourceLine(CLOSE_BRACE +
	    BeanGenerator.format(BEANKEYS_CLASS_CLOSE, className), 0));
	return (sb);

    } // getBeanKeysClass

    /**
     * This method returns the closing line of code in the Class.
     *
     * @return	StringBuffer	closing line of code in the Class
     */
    private StringBuffer getClassClose() {

	StringBuffer sb = new StringBuffer(CLOSE_BRACE);
	sb.append(BeanGenerator.format(CLASS_CLOSE, className));
	return (sb);

    } // getClassClose

    /**
     * This method returns all generated JavaDoc and methods related to 
     * the properties in the class. These include accessor, mutator, 
     * display name accessor, units accessor, and invokeMethods.
     *
     * @return	StringBuffer	JavaDoc and methods related to class properties
     */
    private StringBuffer getPropertyMethods() {

	StringBuffer sb = new StringBuffer();
	// make sure there are actually properties defined in the class.
	//
	if (!BeanGenerator.hasContents(vProperties)) {

	    return (sb);

	}
	Enumeration enumeration = vProperties.elements();
	CIMProperty cimProp;
	while (enumeration.hasMoreElements()) {

	    cimProp = (CIMProperty)enumeration.nextElement();
	    // strip inherited properties from the container of all
	    // properties defined in the CIM class AND inherited 
	    // properties. we have to define non-overridden properties
	    // as abstract in order to implement the required
	    // interface.
	    //
	    sb.append(generatePropertyMethods(cimProp));

	}

	// chop off the extra newline before returning
	//
	return (sb.append(RETURN));

    } // getPropertyMethods

    /**
     * This method generates the relevant methods for the specified property.
     * 
     * @param cimProp property to generate property methods for
     * @return StringBuffer properly formatted property methods
     */
    private StringBuffer generatePropertyMethods(CIMProperty cimProp) {

	boolean hasConstants = BeanGenerator.hasQualifier(cimProp, VALUEMAP) ||
	    BeanGenerator.hasQualifier(cimProp, VALUES);

	StringBuffer sb = new StringBuffer();
	cimProp.setOriginClass(className);

	// since we don't want to special case these methods for
	// ValueMap/Values qualified properties, let the accessor/mutator
	// generation fall through to getConstantsMethods(), but generate
	// Units/DisplayName methods as appropriate
	//
	if (!hasConstants) {

	    sb.append(BeanGenerator.getAccessorDoc(cimProp));
	    sb.append(getAccessor(cimProp));
	    sb.append(BeanGenerator.getMutatorDoc(cimProp));
	    sb.append(getMutator(cimProp));

	}
	StringBuffer tmpBuffer = BeanGenerator.getUnitsDoc(cimProp);
	if (BeanGenerator.hasContents(tmpBuffer)) {

	    sb.append(tmpBuffer).append(getUnits(cimProp));

	}
	tmpBuffer = BeanGenerator.getDisplayNameDoc(cimProp);
	if (BeanGenerator.hasContents(tmpBuffer)) {

	    sb.append(tmpBuffer).append(getDisplayName(cimProp));

	}
	if (hasConstants && !BeanGenerator.hasQualifier(cimProp, OVERRIDE)) {

	    sb.append(getConstants(cimProp));
	    sb.append(getConstantsMethods(cimProp));

	}
	return (sb);

    } // generatePropertyMethods

    /**
     * This method returns the code defining the accessor method for the
     * specified property.
     * 
     * @param cimProp property to generate the accessor method for
     * @return accessor method
     */
    private StringBuffer getAccessor(CIMProperty cimProp) {

	String propName = BeanGenerator.firstCharUpper(
	    cimProp.getName()).toString();
	StringBuffer dataType = BeanGenerator.getPropertyDataType(cimProp);
	if (BeanGenerator.hasQualifier(cimProp, OVERRIDE)) {

	    dataType = BeanGenerator.getOverriddenDataType(cimClass, cimProp);

	}
	StringBuffer sb = BeanGenerator.getSourceLine(BeanGenerator.format(
	    CLASS_ACCESSOR_OPEN, dataType.toString(), propName, 
	    BeanGenerator.getExceptions().toString()) + OPEN_BRACE + RETURN, 1);

	// array type properties need a different method body as 
	// CIMBeanImpl.getProperty() returns a Vector whose contents must 
	// be moved into a <datatype>[]
	//
	if (BeanGenerator.isArrayType(BeanGenerator.getDataType(
	    cimProp.getType()))) {

	    // remove the array suffix, since its in the code constants
	    // as needed. note: getPropertyDataType() may have removed
	    // it already. refer to that method for details. 
	    //
	    if ((dataType.toString()).lastIndexOf(ARRAY_SUFFIX) > 0) {

		dataType = new StringBuffer(dataType.substring(0, 
		    dataType.length() - 2));

	    }
	    sb.append(BeanGenerator.getSourceLine(BeanGenerator.format(
		CLASS_ACCESSOR_ARRAYBODY, propName), 2));
	    sb.append(BeanGenerator.getSourceLine(BeanGenerator.format(
		CLASS_ACCESSOR_ARRAYBODY2, dataType.toString()), 2));
	    sb.append(BeanGenerator.getSourceLine(CLASS_ACCESSOR_ARRAYBODY3, 
		2));
	    sb.append(BeanGenerator.getSourceLine(BeanGenerator.format(
		CLASS_ACCESSOR_ARRAYBODY4, dataType.toString()), 3));
	    sb.append(CLASS_ACCESSOR_ARRAYBODY5);
	    sb.append(BeanGenerator.getSourceLine(BeanGenerator.format(
		CLASS_ACCESSOR_ARRAYBODY6, dataType.toString()), 4));
	    sb.append(CLASS_ACCESSOR_ARRAYBODY7);

	} else {

	    // Association properties call a different utility method
	    //
	    if (cimProp.isReference()) {

		sb.append(BeanGenerator.getSourceLine(BeanGenerator.format(
		    CLASS_ACCESSOR_ASSOCBODY1, dataType.toString()), 2));
		sb.append(BeanGenerator.getSourceLine(CLASS_ACCESSOR_ASSOCBODY2,
		    2));
		sb.append(BeanGenerator.getSourceLine(BeanGenerator.format(
		    CLASS_ACCESSOR_ASSOCBODY3, propName), 3));
		sb.append(BeanGenerator.getSourceLine(CLASS_ACCESSOR_ASSOCBODY4,
		    2));
		sb.append(BeanGenerator.getSourceLine(CLOSE_BRACE + RETURN, 2));
		sb.append(BeanGenerator.getSourceLine(BeanGenerator.format(
		    CLASS_ACCESSOR_ASSOCBODY5, dataType.toString()), 2));

	    } else {

		sb.append(BeanGenerator.getSourceLine(BeanGenerator.format(
		    CLASS_ACCESSOR_BODY, dataType.toString(), propName) + 
		    RETURN, 2));

	    }

	}
	sb.append(BeanGenerator.getSourceLine(CLOSE_BRACE + 
	    BeanGenerator.format(ACCESSOR_CLOSE, cimProp.getName()), 1));
	return (sb.append(RETURN));

    } // getAccessor

    /**
     * This method returns the code defining the accessor method for the
     * specified property in the BeanKeys container class.
     * 
     * @param cimProp property to generate the accessor method for
     * @return StringBuffer BeanKeys accessor method
     */
    private StringBuffer getBeanKeysAccessor(CIMProperty cimProp) {

	String propName = BeanGenerator.firstCharUpper(
	    cimProp.getName()).toString();
	StringBuffer sb = BeanGenerator.getSourceLine(BeanGenerator.format(
	    ACCESSOR_OPEN, BeanGenerator.getDataType(
	    cimProp.getType()).toString(), propName) + OPEN_BRACE + RETURN, 1);

	sb.append(BeanGenerator.getSourceLine(BeanGenerator.format(
	    ACCESSOR_BODY, BeanGenerator.getParameterName(propName)) + RETURN, 
	    2));

	sb.append(BeanGenerator.getSourceLine(CLOSE_BRACE + 
	    BeanGenerator.format(ACCESSOR_CLOSE, propName), 1));
	return (sb.append(RETURN));

    } // getBeanKeysAccessor

    /**
     * This method returns the code defining the mutator method for the
     * specified property.
     * 
     * @param cimProp the property to get the mutator method for
     * @return StringBuffer mutator method
     */
    private StringBuffer getMutator(CIMProperty cimProp) {

	String propName = BeanGenerator.firstCharUpper(
	    cimProp.getName()).toString();
	String propVar = BeanGenerator.getParameterName(propName);
	StringBuffer dataType = BeanGenerator.getPropertyDataType(cimProp);
	if (BeanGenerator.hasQualifier(cimProp, OVERRIDE)) {

	    dataType = BeanGenerator.getOverriddenDataType(cimClass, cimProp);

	}
	StringBuffer sb = BeanGenerator.getSourceLine(BeanGenerator.format(
	    CLASS_MUTATOR_OPEN, propName, dataType.toString(), propVar, 
	    BeanGenerator.getExceptions().toString()) + OPEN_BRACE + RETURN, 1);

	// array type properties need a different method body as 
	// CIMBeanImpl.setProperty() requires a Vector
	//
	if (BeanGenerator.isArrayType(BeanGenerator.getDataType(
	    cimProp.getType()))) {

	    sb.append(BeanGenerator.getSourceLine(BeanGenerator.format(
		CLASS_MUTATOR_ARRAYBODY, propVar), 2));
	    sb.append(BeanGenerator.getSourceLine(BeanGenerator.format(
		CLASS_MUTATOR_ARRAYBODY2, propVar) + OPEN_BRACE, 2));
	    sb.append(RETURN);
	    sb.append(BeanGenerator.getSourceLine(BeanGenerator.format(
		CLASS_MUTATOR_ARRAYBODY3, propVar) + RETURN, 3));
	    sb.append(BeanGenerator.getSourceLine(CLOSE_BRACE + RETURN, 2));
	    sb.append(BeanGenerator.getSourceLine(BeanGenerator.format(
		CLASS_MUTATOR_ARRAYBODY4, cimProp.getName(), propVar) + RETURN, 
		2));

	} else {

	    sb.append(BeanGenerator.getSourceLine(BeanGenerator.format(
		CLASS_MUTATOR_BODY, cimProp.getName(), propVar) + RETURN, 2));

	}
	sb.append(BeanGenerator.getSourceLine(CLOSE_BRACE + 
	    BeanGenerator.format(MUTATOR_CLOSE, cimProp.getName()), 1));
	return (sb.append(RETURN));

    } // getMutator

    /**
     * This method returns the code defining the units accessor method for the
     * specified property. NOTE: This method is called only when
     * BeanGenerator.getUnitsDoc() determines there is a Units qualifier for
     * the property.
     * 
     * @param cimProp the property to get the units method for
     * @return StringBuffer units accessor method
     */
    private StringBuffer getUnits(CIMProperty cimProp) {

	StringBuffer sb = BeanGenerator.getSourceLine(BeanGenerator.format(
	    CLASS_UNITS_OPEN, cimProp.getName(), 
	    BeanGenerator.getExceptions().toString()) + OPEN_BRACE + RETURN, 1);

	sb.append(BeanGenerator.getSourceLine(BeanGenerator.format(
	    CLASS_UNITS_BODY, BeanGenerator.getQualifier(cimProp, UNITS)) +
	    RETURN, 2));
	    
	sb.append(BeanGenerator.getSourceLine(CLOSE_BRACE + 
	    BeanGenerator.format(CLASS_UNITS_CLOSE, cimProp.getName()), 1));
	return (sb.append(RETURN));

    } // getUnits

    /**
     * This method returns the code defining the display name accessor method
     * for the specified property. NOTE: This method is called only when
     * BeanGenerator.getUnitsDoc() determines there is a DisplayName qualifier
     * for the property.
     * 
     * @param cimProp property to get the display name method for
     * @return StringBuffer display name accessor method
     */
    private StringBuffer getDisplayName(CIMProperty cimProp) {

	StringBuffer sb = BeanGenerator.getSourceLine(
	    BeanGenerator.format(CLASS_DISPLAYNAME_OPEN, 
	    BeanGenerator.firstCharUpper(cimProp.getName()).toString(), 
	    BeanGenerator.getExceptions().toString()) + OPEN_BRACE + RETURN, 1);

	sb.append(BeanGenerator.getSourceLine(BeanGenerator.format(
	    CLASS_DISPLAYNAME_BODY, BeanGenerator.getQualifier(cimProp, 
	    DISPLAYNAME)) + RETURN, 2));

	sb.append(BeanGenerator.getSourceLine(CLOSE_BRACE + 
	    BeanGenerator.format(CLASS_DISPLAYNAME_CLOSE, 
	    BeanGenerator.firstCharUpper(cimProp.getName()).toString()), 
	    1));
	return (sb.append(RETURN));

    } // getDisplayName

    /**
     * This method returns the JavaDoc and code defining the private constants
     * for the ValueMap/Values qualified property specified. NOTE: This method
     * should only be called if the property has the ValueMap and/or Values
     * qualifiers.
     * 
     * @param cimProp ValueMap/Values qualified property
     * @return StringBuffer ValueMap/Values constants
     */
    private StringBuffer getConstants(CIMProperty cimProp) {

	// constant JavaDoc
	//
	StringBuffer sb = BeanGenerator.getJavaDoc(I18N.loadStringFormat(
	    "PROP_VALUEMAP_CONSTANTS_JAVADOC", cimProp.getName()),
	    new StringBuffer(), (Vector)null, 1);

	// constants
	//
	String prefix = cimProp.getName().toUpperCase() + VALUEMAP_PREFIX;
	String dataType = BeanGenerator.getPropertyDataType(cimProp).toString();
	String constantName;
	String constantValue;
	Enumeration eConstantNames = (BeanGenerator.getConstantNames(cimProp, 
	    prefix)).elements();
	Enumeration eConstantValues = (BeanGenerator.getValueMapConstantValues(
	    cimProp)).elements();

	// the Enumerations have a 1-1 relationship, so looping through
	// either is acceptable
	//
	while (eConstantNames.hasMoreElements()) {

	    constantName = (String)eConstantNames.nextElement();
	    constantValue = (String)eConstantValues.nextElement();
	    sb.append(BeanGenerator.getSourceLine(BeanGenerator.format(
		VALUEMAP_CONSTANT, dataType, constantName, constantValue), 1));

	}

	// ValueMap constants array
	//
        String arrayName = getValueMapArrayName(cimProp);
	StringBuffer arrayBuffer = new StringBuffer("{");
	eConstantNames = (BeanGenerator.getConstantNames(cimProp,
	    prefix)).elements();
	while (eConstantNames.hasMoreElements()) {

	    constantName = (String)eConstantNames.nextElement();
	    arrayBuffer.append(constantName).append(COMMA);

	}
	String arrayStr = arrayBuffer.substring(0,
	    (arrayBuffer.toString()).lastIndexOf(COMMA)) + "}";
	sb.append(BeanGenerator.getSourceLine(BeanGenerator.format(
	    VALUEMAP_CONSTANTS_ARR, dataType, arrayName, arrayStr), 1));

	// Values constants array
	//
	prefix = cimProp.getName().toUpperCase() + VALUES_PREFIX;
	arrayName = getValuesArrayName(cimProp);
	arrayBuffer = new StringBuffer("{");
	eConstantNames = (BeanGenerator.getConstantNames(cimProp,
	    prefix)).elements();
	while (eConstantNames.hasMoreElements()) {

	    constantName = (String)eConstantNames.nextElement();
	    arrayBuffer.append(constantName).append(COMMA);

	}
	arrayStr = arrayBuffer.substring(0, (arrayBuffer.toString()).lastIndexOf(COMMA)) + 
	    "}";
	sb.append(BeanGenerator.getSourceLine(BeanGenerator.format(
	    VALUES_CONSTANTS_ARR, arrayName, arrayStr), 1));

	return (sb.append(RETURN));

    } // getConstants

    /**
     * This method returns the JavaDoc and code defining the private constants
     * for the ValueMap/Values qualified invokeMethod parameter specified.
     * NOTE: This method should only be called if the parameter has the
     * ValueMap and/or Values qualifiers.
     * 
     * @param cimParam ValueMap/Values qualified invokeMethod parameter
     * @param name invokeMethod name the parameter came from
     * @return ValueMap/Values constants
     */
    private StringBuffer getConstants(CIMParameter cimParam, String name) {

	// constant JavaDoc
	//
	StringBuffer sb = BeanGenerator.getJavaDoc(I18N.loadStringFormat(
	    "PARAM_VALUEMAP_CONSTANTS_JAVADOC", cimParam.getName(), name),
	    new StringBuffer(), (Vector)null, 1);

	// constants
	//
	String prefix = name.toUpperCase() + "_" +
	    cimParam.getName().toUpperCase() + VALUEMAP_PREFIX;
        CIMDataType type = cimParam.getType();
        if(type.isArrayType()) {
            type = CIMDataType.getPredefinedType(
                    CIMDataType.findSimpleType(type.getType()));
        }
        String dataType = BeanGenerator.getDataType(type).toString();
	String constantName;
	String constantValue;
	Enumeration eConstantNames = (BeanGenerator.getConstantNames(cimParam, 
	    prefix)).elements();
	Enumeration eConstantValues = (BeanGenerator.getValueMapConstantValues(
	    cimParam)).elements();

	// the Enumerations have a 1-1 relationship, so looping through
	// either is acceptable
	//
	while (eConstantNames.hasMoreElements()) {

	    constantName = (String)eConstantNames.nextElement();
	    constantValue = (String)eConstantValues.nextElement();
	    sb.append(BeanGenerator.getSourceLine(BeanGenerator.format(
		VALUEMAP_CONSTANT, dataType, constantName, constantValue), 1));

	}

	// ValueMap constants array
	//
        String arrayName = getValueMapArrayName(cimParam, name);
	StringBuffer arrayBuffer = new StringBuffer("{");
	eConstantNames = (BeanGenerator.getConstantNames(cimParam,
	    prefix)).elements();
	while (eConstantNames.hasMoreElements()) {

	    constantName = (String)eConstantNames.nextElement();
	    arrayBuffer.append(constantName).append(COMMA);

	}
	String arrayStr = arrayBuffer.substring(0,
	    (arrayBuffer.toString()).lastIndexOf(COMMA)) + "}";
	sb.append(BeanGenerator.getSourceLine(BeanGenerator.format(
	    VALUEMAP_CONSTANTS_ARR, dataType, arrayName, arrayStr), 1));

	// Values constants array
	//
	prefix = name.toUpperCase() + "_" +
	    cimParam.getName().toUpperCase() + VALUES_PREFIX;
	arrayName = getValuesArrayName(cimParam, name);
	arrayBuffer = new StringBuffer("{");
	eConstantNames = (BeanGenerator.getConstantNames(cimParam,
	    prefix)).elements();
	while (eConstantNames.hasMoreElements()) {

	    constantName = (String)eConstantNames.nextElement();
	    arrayBuffer.append(constantName).append(COMMA);

	}
	arrayStr = arrayBuffer.substring(0, (arrayBuffer.toString()).lastIndexOf(COMMA)) + 
	    "}";
	sb.append(BeanGenerator.getSourceLine(BeanGenerator.format(
	    VALUES_CONSTANTS_ARR, arrayName, arrayStr), 1));

	return (sb.append(RETURN));

    } // getConstants

    /**
     * This method returns the name of the array that holds the class's private
     * property Values/ValueMap constants. NOTE: This method should only be
     * called if the property has the ValueMap/Values qualifiers.
     * 
     * @param cimProp property to get the array name for
     * @return array name for constants array
     */
    private String getValueMapArrayName(CIMProperty cimProp) {

	String arrayName = BeanGenerator.format(VALUEMAP_ARRAY_NAME, 
	    BeanGenerator.firstCharLower(cimProp.getName()).toString());
	return (arrayName);

    } // getValueMapArrayName

    /**
     * This method returns the name of the array that holds the class's private
     * invokeMethod parameter Values/ValueMap constants. NOTE: This method
     * should only be called if the invokeMethod parameter has the
     * ValueMap/Values qualifiers.
     * 
     * @param cimParam invokeMethod parameter to get the array name for
     * @param name invokeMethod name
     * @return array name for constants array
     */
    private String getValueMapArrayName(CIMParameter cimParam, String name) {

	String arrayName = BeanGenerator.format(VALUEMAP_ARRAY_NAME, 
	    BeanGenerator.firstCharLower(name).toString() + "_" +
	    BeanGenerator.firstCharUpper(cimParam.getName()).toString());
	return (arrayName);

    } // getValueMapArrayName

    /**
     * This method returns the name of the array that holds the Interface's
     * public Values constants for the specified Values/ValueMap qualified
     * property. NOTE: This method should only be called if the property has
     * the ValueMap/Values qualifiers.
     * 
     * @param cimProp property to get the array name for
     * @return array name for constants array
     */
    private String getValuesArrayName(CIMProperty cimProp) {

	String arrayName = BeanGenerator.format(VALUES_ARRAY_NAME,
	    BeanGenerator.firstCharLower(cimProp.getName()).toString());
	return (arrayName);

    } // getValuesArrayName

    /**
     * This method returns the name of the array that holds the Interface's
     * public Values constants for the specified Values/ValueMap qualified
     * invokeMethod parameter. NOTE: This method should only be called if the
     * invokeMethod parameter has the ValueMap/Values qualifiers.
     * 
     * @param cimParam invokeMethod parameter to get the array name for
     * @param name invokeMethod name
     * @return array name for constants array
     */
    private String getValuesArrayName(CIMParameter cimParam, String name) {

	String arrayName = BeanGenerator.format(VALUES_ARRAY_NAME,
	    BeanGenerator.firstCharLower(name).toString() + "_" +
	    BeanGenerator.firstCharUpper(cimParam.getName()).toString());
	return (arrayName);

    } // getValuesArrayName

    /**
     * This method returns the JavaDoc and code defining the accessor,
     * mutator, and constant accessor methods for the specified
     * ValueMap/Values qualified property. The following outlines the
     * methods generated:
     *
     * public String get<Prop>(); // accessor
     * public void set<Prop>(String) throws IllegalArgumentException; // mutator
     * public String[] get<Prop>Values(); // constants accessor
     *
     * NOTE: This method should only be called when the specified property 
     * has the ValueMap and/or Values qualifiers. Also, the String datatype
     * in the accessor/mutator method signature above is String[] if the
     * property is an array datatype.
     *
     * @param	cimProp	ValueMap/Values qualified property
     * @return	ValueMap/Values JavaDoc and convenience methods
     */
    private StringBuffer getConstantsMethods(CIMProperty cimProp) {

	boolean hasValues = BeanGenerator.hasQualifier(cimProp, VALUES) ||
	    BeanGenerator.hasQualifier(cimProp, VALUEMAP);
	StringBuffer dataType = new StringBuffer(STRING);

	// if the property is an array type, we need to use String[] as
	// the accessor/mutator datatype.
	//
	StringBuffer realType = BeanGenerator.getDataType(cimProp.getType());
	boolean isArrayType = BeanGenerator.isArrayType(realType);
	if (isArrayType) {

	    dataType = new StringBuffer(STRING_ARRAY);

	}
	String realDataType = BeanGenerator.getPropertyDataType(
	    cimProp).toString();
	String propName = BeanGenerator.firstCharUpper(
	    cimProp.getName()).toString();

	// accessor JavaDoc
	//
        JavaDocElement javaDocElement = new JavaDocElement(JAVADOC_RETURN_TAG,
	    dataType, I18N.loadStringFormat("ACCESSOR_RETURN_DESCRIPTION",
	    propName));
	Vector vJavaDocElements = new Vector(1);
	vJavaDocElements.addElement(javaDocElement);
	StringBuffer sb = BeanGenerator.getJavaDoc(I18N.loadStringFormat(
	    "BEAN_ACCESSOR_JAVADOC", className, cimProp.getName()),
	    BeanGenerator.getPropertyDescription(cimProp), vJavaDocElements, 1);

	// accessor
	//
	sb.append(BeanGenerator.getSourceLine(BeanGenerator.format(
	    CLASS_ACCESSOR_OPEN, dataType.toString(), propName,
	    BeanGenerator.getExceptions().toString()), 1));
	sb.append(OPEN_BRACE).append(RETURN);

	// body of method depends upon whether the datatype of the property
	// is an array
	//
	if (isArrayType) {

	    sb.append(BeanGenerator.getSourceLine(BeanGenerator.format(
		VALUEMAP_ACCESSOR_ARRAYBODY, propName,
		getValuesArrayName(cimProp), getValueMapArrayName(cimProp)),
		2));

	} else {

	    sb.append(BeanGenerator.getSourceLine(BeanGenerator.format(
		VALUEMAP_ACCESSOR_BODY, getValueMapArrayName(cimProp), 
		realDataType, cimProp.getName()), 2));
	    // no guarantee that the property is populated. return null if it
	    // is not.
	    //
	    sb.append(VALUEMAP_ACCESSOR_BODY2);

	    sb.append(BeanGenerator.getSourceLine(BeanGenerator.format(
		VALUEMAP_ACCESSOR_RETURN, getValuesArrayName(cimProp)), 2));

	}
	sb.append(RETURN);
	sb.append(BeanGenerator.getSourceLine(CLOSE_BRACE +
	    BeanGenerator.format(ACCESSOR_CLOSE, propName), 1));
	sb.append(RETURN);

	// mutator JavaDoc
	//
        javaDocElement = new JavaDocElement(JAVADOC_PARAM_TAG, dataType,
	    I18N.loadStringFormat("MUTATOR_PARAM_DESCRIPTION", propName));
	vJavaDocElements = new Vector(2);
	vJavaDocElements.addElement(javaDocElement);
	javaDocElement = new JavaDocElement(JAVADOC_EXCEPTION_TAG,
	    new StringBuffer(CIMEXCEPTION),
	    I18N.loadString("CIMEXCEPTION_DESCRIPTION"));
	vJavaDocElements.addElement(javaDocElement);
	sb.append(BeanGenerator.getJavaDoc(I18N.loadStringFormat(
	    "BEAN_MUTATOR_JAVADOC", className, cimProp.getName()),
	    BeanGenerator.getPropertyDescription(cimProp), vJavaDocElements,
	    1));

	// mutator
	//
	String propVar = BeanGenerator.getParameterName(propName);
	sb.append(BeanGenerator.getSourceLine(BeanGenerator.format(
	    CLASS_MUTATOR_OPEN, propName, dataType.toString(), propVar,
	    THROWS_CIMEXCEPTION), 1));
	sb.append(OPEN_BRACE).append(RETURN);

	// body of method depends upon whether the datatype of the property
	// is an array
	//
	if (isArrayType) {

	    sb.append(BeanGenerator.getSourceLine(BeanGenerator.format(
		VALUEMAP_MUTATOR_ARRAYBODY, propName,
		getValuesArrayName(cimProp), getValueMapArrayName(cimProp),
		propVar), 2));

	} else {

	    sb.append(BeanGenerator.getSourceLine(BeanGenerator.format(
		VALUEMAP_MUTATOR_BODY, getValuesArrayName(cimProp), 
		propVar), 2));
	    sb.append(VALUEMAP_MUTATOR_BODY2);
	    sb.append(BeanGenerator.getSourceLine(BeanGenerator.format(
		VALUEMAP_MUTATOR_BODY3, propName, 
		getValueMapArrayName(cimProp)), 2));

	}
	sb.append(RETURN);
	sb.append(BeanGenerator.getSourceLine(CLOSE_BRACE + 
	    BeanGenerator.format(MUTATOR_CLOSE, propName), 1));
	sb.append(RETURN);

	// constants accessor
	//
	if (hasValues) {

	    // String[] get<Prop>Values() JavaDoc
	    //
	    javaDocElement = new JavaDocElement(JAVADOC_RETURN_TAG,
		new StringBuffer(STRING_ARRAY), 
		I18N.loadString("VALUESACCESSOR_RETURN_DESCRIPTION"));
	    vJavaDocElements = new Vector(1);
	    vJavaDocElements.addElement(javaDocElement);
	    sb.append(BeanGenerator.getJavaDoc(I18N.loadStringFormat(
		"PROP_VALUES_ACCESSOR_JAVADOC", className, cimProp.getName()),
		new StringBuffer(), vJavaDocElements, 1));

	    // String[] get<Prop>Values() open
	    //
	    sb.append(BeanGenerator.getSourceLine(BeanGenerator.format(
		GETVALUES_OPEN, propName) + SPACE + OPEN_BRACE + RETURN, 1));

	    // String[] get<Prop>Values() body
	    //
	    sb.append(BeanGenerator.getSourceLine(BeanGenerator.format(
		GETVALUES_BODY, getValuesArrayName(cimProp)), 2));
	    sb.append(RETURN);

	    // String[] get<Prop>Values() close
	    //
	    sb.append(BeanGenerator.getSourceLine(CLOSE_BRACE + 
		BeanGenerator.format(GETVALUES_CLOSE, propName), 1));

	}
	return (sb.append(RETURN));

    } // getConstantsMethods

    /**
     * This method returns the JavaDoc and code defining the constant 
     * accessor method for the specified ValueMap/Values qualified 
     * invokeMethod parameter. The following outlines the signature of
     * the method generated:
     *
     * public String[] get<Method>_<Prop>Values();
     *
     * NOTE: This method should only be called when the specified parameter 
     * has the ValueMap and/or Values qualifiers.
     *
     * @param	cimParam	ValueMap/Values qualified invokeMethod parameter
     * @param	methodName		invokeMethod name
     * @return	ValueMap/Values JavaDoc and convenience methods
     */
    private StringBuffer getConstantsMethod(CIMParameter cimParam,
	String methodName) {

	StringBuffer sb = new StringBuffer();
	StringBuffer dataType = new StringBuffer(STRING_ARRAY);
	String paramName = BeanGenerator.firstCharUpper(
	    cimParam.getName()).toString();
	String name = BeanGenerator.firstCharUpper(methodName).toString() +
	    "_" + paramName;

	// constant accessor JavaDoc
	//
	JavaDocElement javaDocElement = new JavaDocElement(JAVADOC_RETURN_TAG,
	    dataType, I18N.loadString("VALUESACCESSOR_RETURN_DESCRIPTION"));
	Vector vJavaDocElements = new Vector(1);
	vJavaDocElements.addElement(javaDocElement);
	Object[] objArr = {className, methodName, paramName};
	sb.append(BeanGenerator.getJavaDoc(I18N.loadStringFormat(
	    "PARAM_VALUES_ACCESSOR_JAVADOC", objArr),
	    new StringBuffer(), vJavaDocElements, 1));

	// constants accessor
	//
	sb.append(BeanGenerator.getSourceLine(BeanGenerator.format(
	    GETVALUES_OPEN, name) + SPACE + OPEN_BRACE + RETURN, 1));

	// constants accessor body
	//
	sb.append(BeanGenerator.getSourceLine(BeanGenerator.format(
	    GETVALUES_BODY, getValuesArrayName(cimParam, methodName)), 2));
	sb.append(RETURN);

	// constants accessor close
	//
	sb.append(BeanGenerator.getSourceLine(CLOSE_BRACE + 
	    BeanGenerator.format(GETVALUES_CLOSE, name), 1));
	return (sb.append(RETURN));

    } // getConstantsMethod

    /**
     * This method returns all generated JavaDoc and the Class equivalent 
     * of the invokeMethods in the CIM class.
     *
     * @return	StringBuffer	JavaDoc and methods for the invokeMethods
     */
    private StringBuffer getInvokeMethods() {

	StringBuffer sb = new StringBuffer();
	// make sure there are actually invokeMethods defined in the class.
	//
	if (!BeanGenerator.hasContents(vMethods)) {

	    return (sb);

	}
	Enumeration eMethods = vMethods.elements();
	CIMMethod cimMethod;
	CIMParameter cimParam;
	Vector vParams;
	while (eMethods.hasMoreElements()) {

	    cimMethod = (CIMMethod)eMethods.nextElement();

	    // generate Java constants for Values/ValueMap qualified method
	    // parameters
	    //
	    vParams = cimMethod.getParameters();
	    if (BeanGenerator.hasContents(vParams)) {

		Enumeration eParams = vParams.elements();
		while (eParams.hasMoreElements()) {

		    cimParam = (CIMParameter)eParams.nextElement();
		    if (BeanGenerator.hasQualifier(cimParam, VALUES) ||
			BeanGenerator.hasQualifier(cimParam, VALUEMAP)) {

			sb.append(getConstants(cimParam, cimMethod.getName()));
			sb.append(getConstantsMethod(cimParam,
			    cimMethod.getName()));

		    }

		}

	    }
	    cimMethod.setOriginClass(className);
	    sb.append(BeanGenerator.getInvokeMethodDoc(cimMethod));
	    sb.append(getInvokeMethod(cimMethod));

	    // generate a <MethodName>Output Class if the method
	    // has an [OUT] qualified parameter
	    //
	    if (BeanGenerator.hasOutParameter(cimMethod)) {

		sb.append(getMethodOutputClass(cimMethod));

	    }

	}
	// chop off the extra newline before returning
	//
	return (new StringBuffer(sb.substring(0, sb.length() - 1)));

    } // getInvokeMethods

    /**
     * This method returns the code defining the Class equivalent of 
     * the invokeMethod specified.
     *
     * @param	cimMethod	the invokeMethod to get the method for
     * @return	Bean method equivalent to the invokeMethod
     */
    private StringBuffer getInvokeMethod(CIMMethod cimMethod) {

	StringBuffer sb = new StringBuffer();
	String methodName = cimMethod.getName();
	StringBuffer dataType = BeanGenerator.getDataType(cimMethod.getType());

	sb.append(BeanGenerator.getSourceLine(BeanGenerator.format(
	    CLASS_INVOKEMETHOD_OPEN, dataType.toString(), methodName,
	    BeanGenerator.getInvokeMethodParams(cimMethod).toString(),
	    BeanGenerator.getInvokeMethodExceptions().toString()) 
	    + OPEN_BRACE + RETURN, 1));


    
        CIMParameter[] inParams  = BeanGenerator.getInParameters(cimMethod);
        CIMParameter[] outParams = BeanGenerator.getOutParameters(cimMethod);

        // add the vInParams and vOutParams declarations
	//
	sb.append(BeanGenerator.getSourceLine(
                    BeanGenerator.format(INVOKEMETHOD_INVECTOR_DECL, 
                            String.valueOf(inParams.length)), 2));
        sb.append(BeanGenerator.getSourceLine(
                    BeanGenerator.format(INVOKEMETHOD_OUTVECTOR_DECL, 
                            String.valueOf(outParams.length)) + RETURN, 2));

	// add a CIMValue to vInParams for each input parameter in the method
	//
	if (BeanGenerator.hasContents(inParams)) {

	    String paramName;
	    String arg;
	    boolean hasValues;
	    for (int i = 0; i < inParams.length; i++) {
            
		CIMParameter cimParam = inParams[i];
		hasValues = (BeanGenerator.hasQualifier(cimParam, VALUES) ||
		    BeanGenerator.hasQualifier(cimParam, VALUEMAP));
		paramName = BeanGenerator.getParameterName(cimParam.getName());
		arg = paramName;

		// if the parameter has Values/ValueMap qualifiers, we
		// have to look up the constant of the originally defined 
		// datatype corresponding to the specified String constant.
		//
		if (hasValues) {
		    arg = BeanGenerator.format(INVOKEMETHOD_PARAM_INVECTOR_ADD,
			getValueMapArrayName(cimParam, methodName),
			getValuesArrayName(cimParam, methodName), paramName);

		}
		
		sb.append(BeanGenerator.getSourceLine(BeanGenerator.format(
		    INVOKEMETHOD_INVECTOR_ADD, String.valueOf(i), paramName, arg), 2));

	    }
	    sb.append(RETURN);
	}

	sb.append(BeanGenerator.getSourceLine(BeanGenerator.format(
	    INVOKEMETHOD_INVOKE, methodName) + RETURN, 2));

	if (BeanGenerator.hasContents(BeanGenerator.getOutParameters(
	    cimMethod))) {

	    sb.append(BeanGenerator.getSourceLine(INVOKEMETHOD_OUTPUT_OPEN + 
		OPEN_BRACE + RETURN, 2));

	    sb.append(BeanGenerator.getSourceLine(BeanGenerator.format(
		INVOKEMETHOD_OUTPUT_BODY, BeanGenerator.getOutputParameterName(
		cimMethod).toString(), 
		BeanGenerator.getOutputInterfaceName(cimMethod).toString(),
		BeanGenerator.getOutputClassName(cimMethod).toString(),
		getOutputParameters(cimMethod)) + RETURN, 3));

	    sb.append(BeanGenerator.getSourceLine(CLOSE_BRACE + RETURN, 2));

	}
	sb.append(BeanGenerator.getSourceLine(BeanGenerator.format(
	    INVOKEMETHOD_RETURN, 
	    BeanGenerator.getDataType(cimMethod.getType()).toString()), 2));

	sb.append(RETURN + BeanGenerator.getSourceLine(CLOSE_BRACE + 
	    BeanGenerator.format(INVOKEMETHOD_CLOSE, methodName), 1));
	return (sb.append(RETURN).append(RETURN));

    } // getInvokeMethod

    /**
     * This method returns the <CIMClass>_<MethodName>OutputImpl Class, which 
     * implements the generated <CIMClass>_<MethodName>Output Interface. An
     * instance of this Interface is required as the last parameter of the 
     * Bean's version of the specified invokeMethod.
     *
     * Since the <CIMClass>_<MethodName>OutputImpl Class is generated as an 
     * inner class of the <CIMClass>BeanImpl Class, a null instance of this
     * Interface must be passed to <CIMClass>Bean when this method is invoked. 
     * The <CIMClass>BeanImpl that implements this Interface constructs an 
     * instance of <CIMClass>_<MethodName>OutputImpl with the output resulting 
     * from the method invokation and assigns it to its handle to the 
     * <CIMClass>_<MethodName>Output Interface.
     *
     * NOTE: This method should only be called if there is at least one [OUT] 
     * qualified parameter in the specified invokeMethod.
     *
     * @param	cimMethod	invokeMethod to get 
     *				<CIMClass>_<MethodName>OutputImpl Class for
     * @return	<CIMClass>_<MethodName>OutputImpl Class
     */
    private StringBuffer getMethodOutputClass(CIMMethod cimMethod) {

	StringBuffer sb = new StringBuffer();
	String className = 
	    BeanGenerator.getOutputClassName(cimMethod).toString();

	// Class JavaDoc
	//
	sb.append(BeanGenerator.getJavaDoc(I18N.loadStringFormat(
	    "METHODOUTPUT_CLASS_JAVADOC", cimMethod.getOriginClass(), 
	    cimMethod.getName()), BeanGenerator.getMethodDescription(cimMethod),
	    (Vector)null, 1));

	// Class definition
	//
	sb.append(BeanGenerator.getSourceLine(BeanGenerator.format(
	    METHODOUTPUT_CLASS_OPEN, className, 
	    BeanGenerator.getOutputInterfaceName(cimMethod).toString()) + 
	    OPEN_BRACE + RETURN, 1));

	// Variables for OUT property values
	//
	CIMParameter[] outParams = BeanGenerator.getOutParameters(cimMethod);
	
	StringBuffer dataType;
    
        if (BeanGenerator.hasContents(outParams)) {
    
            for (int i = 0; i < outParams.length; i++) {
                CIMParameter cimParam = outParams[i];
                dataType = BeanGenerator.getDataType(cimParam.getType());
                sb.append(BeanGenerator.getSourceLine(BeanGenerator.format(
                                        CLASS_VARIABLE, dataType.toString(), 
                                        BeanGenerator.getParameterName(cimParam.getName())), 2));
                
            }
            sb.append(RETURN);
        }

	// constructor JavaDoc
	//
	Vector vJavaDocElements = new Vector(outParams.length);
	addParamsToVector(vJavaDocElements, outParams);
	sb.append(BeanGenerator.getJavaDoc(BeanGenerator.format(
	    I18N.loadString("METHODOUTPUT_CONSTRUCTOR_JAVADOC"), className, 
	    cimMethod.getOriginClass(), cimMethod.getName()), 
	    new StringBuffer(), vJavaDocElements, 2));

	// constructor open
	//
	sb.append(BeanGenerator.getSourceLine(BeanGenerator.format(
	    METHODOUTPUT_CONSTRUCTOR_OPEN, className, 
	    getOutputConstructorParameters(cimMethod)) + OPEN_BRACE + RETURN, 
	    2));

	// constructor body
	//
	sb.append(BeanGenerator.getSourceLine(SUPERCLASS, 3));
        for (int i = 0; i < outParams.length; i++) {
            CIMParameter cimParam = outParams[i];
	    sb.append(BeanGenerator.getSourceLine(BeanGenerator.format(
		VARIABLE_HANDLE, BeanGenerator.getParameterName(
		cimParam.getName())), 3));

	}
	sb.append(RETURN);

	// constructor close
	//
	sb.append(BeanGenerator.getSourceLine(CONSTRUCTOR_CLOSE + RETURN, 2));

	// output parameter accessor method(s)
	//
	String paramName;
	String paramVar;
        for (int i = 0; i < outParams.length; i++) {
            CIMParameter cimParam = outParams[i];
	    paramName = BeanGenerator.firstCharUpper(
		cimParam.getName()).toString();
	    paramVar = BeanGenerator.getParameterName(paramName);
	    dataType = BeanGenerator.getDataType(cimParam.getType());

	    // output parameter accessor JavaDoc
	    //
	    vJavaDocElements.removeAllElements();
	    vJavaDocElements.addElement(new JavaDocElement(JAVADOC_RETURN_TAG,
		dataType, I18N.loadStringFormat("ACCESSOR_RETURN_DESCRIPTION", 
		paramName)));
	    sb.append(BeanGenerator.getJavaDoc(BeanGenerator.format(
		I18N.loadString("METHODOUTPUT_ACCESSOR_JAVADOC"), 
		paramName, cimMethod.getOriginClass(), cimMethod.getName()), 
		new StringBuffer(), vJavaDocElements, 2));

	    // output parameter accessor open
	    //
	    sb.append(BeanGenerator.getSourceLine(BeanGenerator.format(
		ACCESSOR_OPEN, dataType.toString(), paramName) + OPEN_BRACE + 
		RETURN, 2));

	    // accessor method body
	    //
	    sb.append(BeanGenerator.getSourceLine(BeanGenerator.format(
		ACCESSOR_BODY, paramVar) + RETURN, 3));

	    // accessor method close
	    //
	    sb.append(BeanGenerator.getSourceLine(CLOSE_BRACE + 
		BeanGenerator.format(ACCESSOR_CLOSE, paramName) + RETURN, 2));

	}
	// class close
	//
	sb.append(BeanGenerator.getSourceLine(CLOSE_BRACE + 
	    BeanGenerator.format(METHODOUTPUT_CLASS_CLOSE, className) + RETURN,
	    1));
	return (sb.append(RETURN));

    } // getMethodOutputClass

    /**
     * This method returns a string containing the parameters taken
     * by constructor of the Output container class for the specified 
     * invokeMethod. This string is intended for substition in {2} of
     * BeanGeneratorConstants.INVOKEMETHOD_OUTPUT_BODY.
     *
     * @param	cimMethod	invokeMethod to get Output parameters for
     * @return	properly formatted Output parameters
     */
    private String getOutputParameters(CIMMethod cimMethod) {

	String paramStr = "";
	int counter = 0;
	CIMParameter[] outParams = BeanGenerator.getOutParameters(cimMethod);
	StringBuffer dataType;
	String formatStr;
        for (int i = 0; i < outParams.length; i++) {
            CIMParameter cimParam = outParams[i];
	    dataType = BeanGenerator.getDataType(cimParam.getType());

	    // Array type parameters have to handled differently due to
	    // the fact that a Vector is returned in the CIMValue in the 
	    // vOutParams popeulated by invokeMethod(). This Vector must 
	    // be converted into an array, which involves a slightly
	    // different line of code, but they both take the same args.
	    //
	    if (BeanGenerator.isArrayType(dataType)) {

		formatStr = INVOKEMETHOD_OUTPUT_ARRAY_PARAM;
		// the Array suffix is chopped off since it is in the constant
		// string. this is needed to specify the size of the array
		// in the '[]'.
		dataType = new StringBuffer(dataType.substring(0, 
		    (dataType.toString()).indexOf(ARRAY_SUFFIX)));

	    } else {

		formatStr = INVOKEMETHOD_OUTPUT_PARAM;

	    }
	    paramStr += BeanGenerator.format(formatStr,
		dataType.toString(),
		Integer.toString(counter));
	    counter++;

	}
	return (paramStr.substring(0, paramStr.lastIndexOf(",")));

    } // getOutputParameters

    /**
     * This method returns a string containing the parameters for the
     * constructor of the Output container class associated with the 
     * specified invokeMethod. This string is intended for substition 
     * in {1} of BeanGeneratorConstants.METHODOUTPUT_CONSTRUCTOR_OPEN.
     *
     * @param	cimMethod	invokeMethod to get Output constructor 
     * parameters for
     * @return	properly formatted Output container class parameters
     */
    private String getOutputConstructorParameters(CIMMethod cimMethod) {

	String paramStr = "";
	CIMParameter[] outParams = BeanGenerator.getOutParameters(cimMethod);
	StringBuffer dataType;
        for (int i = 0; i < outParams.length; i++) {
            CIMParameter cimParam = outParams[i];

            dataType = BeanGenerator.getDataType(cimParam.getType());
	    paramStr += BeanGenerator.format(METHOD_PARAM, dataType.toString(),
		BeanGenerator.getParameterName(cimParam.getName()));

	}
	return (paramStr.substring(0, paramStr.lastIndexOf(",")));

    } // getOutputConstructorParameters

    /**
     * This method returns a string containing the parameters taken
     * by constructor of the BeanKeys container class. This string is 
     * intended for substition in {1} of
     * BeanGeneratorConstants.BEANKEYS_CONSTRUCTOR_OPEN.
     *
     * @return	String	properly formatted BeanKeys class constructor params
     */
    private String getBeanKeysParameters() {

	String paramStr = "";
	CIMProperty cimProp;
	Enumeration eKeys = vKeys.elements();
	while (eKeys.hasMoreElements()) {

	    cimProp = (CIMProperty)eKeys.nextElement();
	    paramStr += BeanGenerator.format(METHOD_PARAM, 
		BeanGenerator.getDataType(cimProp.getType()).toString(), 
		BeanGenerator.getParameterName(cimProp.getName()));

	}
	return (paramStr.substring(0, paramStr.lastIndexOf(",")));

    } // getBeanKeysParameters

    /**
     * This method creates JavaDocElements for Parameters from CIMProperty
     * objects and adds them to the end of the specified Vector. This
     * method should only be called if there are CIMProperties in the
     * specified Vector.
     *
     * @param   vJavaDocElements  container of JavaDocElements
     * @param   vProps  container of CIMProperties
     */
    private void addPropsToVector(Vector vJavaDocElements, Vector vProps) {

	CIMProperty cimProp;
	Enumeration eProps = vProps.elements();
	JavaDocElement javaDocElement;
	while (eProps.hasMoreElements()) {

	    cimProp = (CIMProperty)eProps.nextElement();
	    javaDocElement = new JavaDocElement(JAVADOC_PARAM_TAG,
		BeanGenerator.getDataType(cimProp.getType()),
		BeanGenerator.getPropertyDescription(cimProp).toString());
	    vJavaDocElements.addElement(javaDocElement);

	}

    } // addPropsToVector

    /**
     * This method creates JavaDocElements for Parameters from CIMParameter
     * objects and adds them to the end of the specified Vector. This
     * method should only be called if there are CIMParameters in the
     * specified Vector.
     *
     * @param   vJavaDocElements  container of JavaDocElements
     * @param   params  container of CIMParameters
     */
    private void addParamsToVector(Vector vJavaDocElements, CIMParameter[] params) {

	JavaDocElement javaDocElement;
	for (int i = 0; i < params.length; i++) {
	    CIMParameter cimParam = params[i];
	    javaDocElement = new JavaDocElement(JAVADOC_PARAM_TAG,
		BeanGenerator.getDataType(cimParam.getType()),
		I18N.loadStringFormat("INVOKEMETHOD_PARAM_DESCRIPTION", 
		cimParam.getName()));
	    vJavaDocElements.addElement(javaDocElement);
	}
    } // addParamsToVector

} // BeanClassWriter

